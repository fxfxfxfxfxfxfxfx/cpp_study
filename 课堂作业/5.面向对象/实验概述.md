# E22[第8章：类的基本操作]设计一个类Circle，表示圆形。
	Circle类以圆心坐标(x,y)和半径r来确定圆。
	Circle类具有如下方法：
i.	可设置圆心坐标。
ii.	可设置半径。
iii.	可计算圆的面积。
iv.	可计算圆的周长。
     其中pi取3.14159.
main函数如下：

`int main()
{
	CCircle c1;
	double x,y,r1,r2;
	cout<<"输入圆心坐标和半径"<<endl;
	cin>>x>>y>>r1;
	c1.set_xy(x,y);
	c1.set_r(r1);
	cout<<"圆周长和面积: "<<fixed<<setprecision(3)<<c1.get_circlum()<<" "<<c1.get_area()<<endl;
	cout<<"输入新的半径:"<<endl;
	cin>>r2;
	c1.set_r(r2);
	cout<<"圆周长和面积: "<<fixed<<setprecision(3)<<c1.get_circlum()<<" "<<c1.get_area()<<endl;
	system("pause");
	return 0;
}`

# E23 [第8章：类的基本操作]设计一个类Column，表示圆柱体。设圆柱体底面在Z=0的平面内。
	Column类以底面圆（参见E22题）和高来确定圆柱体。
	Column类具有如下方法：
i.	可设置底面圆心。
ii.	可设置底面半径。
iii.	可设置高。
iv.	可计算底面积。
v.	可计算底面的周长。
vi.	可计算侧面积。
vii.	可计算体积。
	测试程序如下：
 `int main()
{
	CColumn c1;
	double x,y,r1,r2,h1,h2;
	cout<<"输入圆心坐标、半径和高"<<endl;
	cin>>x>>y>>r1>>h1;
	c1.SetXY(x,y);
	c1.SetR(r1);
	c1.SetH(h1);
	cout<<"圆柱的底面周长、底面积、侧面积和体积："<<endl;
	cout<<fixed<<setprecision(3)<<c1.GetBottomCirclum()<<" "
		<<c1.GetBottomArea()<<" "
		<<c1.GetSideArea()<<" "
		<<c1.GetVolume()<<endl;
    cout<<"输入底圆半径和高:"<<endl;
	cin>>r2>>h2;
	c1.SetR(r2);
	c1.SetH(h2);
	cout<<"圆柱的底面周长、底面积、侧面积和体积："<<endl;
	cout<<fixed<<setprecision(3)<<c1.GetBottomCirclum()<<" "
		<<c1.GetBottomArea()<<" "
		<<c1.GetSideArea()<<" "
		<<c1.GetVolume()<<endl;

	//system("pause");
	return 0;
} `

# E24 [第8章：类的基本操作，运算符重载]在E22圆形类的基础上，完成如下功能：
	定义加法运算，规则：两圆之和为一个新的圆，圆心是第一个操作数的圆心（如a+b，则a的圆心为a+b的圆心），半径为两圆半径之和。加法运算不改变操作数。
	定义减法运算，规则：两圆之差为一个新的圆，圆心是第一个操作数的圆心，面积为两圆面积之差的绝对值。减法运算不改变操作数。
	定义自增、自减运算（含前/后自增/自减），对半径进行自增、自减运算。
	定义输出流运算，输出圆心坐标、半径、周长、面积，保留3位小数，右对齐。输出样例如下：(圆心坐标 半径 周长 面积)
   (1.000,1.000) 3.000 18.850 28.274
	定义>、<运算，比较两圆面积之间的大小关系。
	定义==、!=运算，比较两圆是否是完全相同的圆，当两个圆的圆心坐标和半径完全一致时则两圆完全相同。
	定义&运算，确定两圆是否同心。
	定义|运算，确定两圆的位置关系（1表示相交、2表示相切、3表示相离、0表示包含）。
	编写主函数如下。
 `int main()
{
	CCircle c1,c2,c3,c4;
	double x1,y1,x2,y2,r1,r2;
	int istate;
	cout<<"请输入圆心坐标和半径: "<<endl;
	cin>>x1>>y1>>r1;
	c1.set_xy(x1,y1);
	c1.set_r(r1);
	cout<<c1<<endl;
	cout<<"请输入圆心坐标和半径: "<<endl;
	cin>>x2>>y2>>r2;
	c2.set_xy(x2,y2);
	c2.set_r(r2);
	cout<<c2<<endl;

    c3=c1+c2;
    cout<<" 两圆相加: "<<c3<<endl;
    c4=c3-c2;
    cout<<" 两圆相减: "<<c4<<endl;
    ++c4;
    cout<<" C4前自增: "<<c4<<endl;
    cout<<" C4后自增: "<<c4++<<" C4自增后: "<<c4<<endl;
    --c4;
    cout<<" C4前自减: "<<c4<<endl;
    cout<<" C4后自减: "<<c4--<<" C4自减后: "<<c4<<endl;

    cout<<"c1: "<<c1<<" c2: "<<c2<<endl;
    if (c1>c2)
        cout<<"c1>c2"<<endl;
    else if (c1<c2)
        cout<<"c1<c2"<<endl;
    else
        cout<<"c1<>c2"<<endl;   // 表示无比较结果

    cout<<"c1: "<<c1<<" c4: "<<c4<<endl;
    if (c1==c4)
        cout<<"c1==c4"<<endl;
    else if (c1 != c4)
        cout<<"c1!=c4"<<endl;
    else
        cout<<"c1<>c4"<<endl;   // 表示无比较结果


    if (c1&c4)
        cout<<"c1与c4同心"<<endl;

    istate = c1|c2;
    switch(istate)
    {
    case 0:
        cout<<"c1包含c2"<<endl;
        break;
    case 1:
        cout<<"c1与c2相交"<<endl;
        break;
    case 2:
        cout<<"c1与c2相切"<<endl;
        break;
    case 3:
        cout<<"c1与c2相离"<<endl;
        break;
    default:
        cout<<"c1与c2位置判断错误"<<endl;
    }
    istate = c3|c1;
    switch(istate)
    {
    case 0:
        cout<<"c3包含c1"<<endl;
        break;
    case 1:
        cout<<"c3与c1相交"<<endl;
        break;
    case 2:
        cout<<"c3与c1相切"<<endl;
        break;
    case 3:
        cout<<"c3与c1相离"<<endl;
    default:
        cout<<"c3与c1位置判断错误"<<endl;
    }

	//system("pause");
	return 0;
} `
	提示：可自行决定是否需要增加圆的属性。但是，不提倡为了简化函数的计算而无原则增加属性。这样做在给某些计算带来方便的同时，也可能会使另外一些计算变复杂。如：在记录半径的情况下，再记录周长和面积，可以简化某些运算符重载函数的代码。但是，半径与周长、面积之间有确定的约束关系需要遵守。所以，增加了面积和周长属性后，改变其中任意一项的值都意味着需要重新计算另外两项的值，否则就会产生数据的不一致。

# E25[第8章：运算符重载，友元函数]设有描述复数的类CComplex定义如下：
 `class CComplex
{
	double m_real;
	double m_image;
public:
	void setValue(double real,double image);  // 设置复数的实部和虚部
}; `
请使用友元函数实现如下重载：
		重载<<运算符，使得可以用cout<<输出复数，每个复数输出的格式为：
	“实部+虚部*i”;
		重载+运算符，使得可以实现两个复数相加；
		重载+运算符，使得可以实现复数和实数的相加；
		重载前置++运算符，使得可以实现复数的实部和虚部分别加1；
		重载后置++运算符，使得可以实现复数的实部和虚部分别加1；
		在main函数中测试并试用这些运算符。main函数如下：
 `int main()
{
	double x1,y1,x2,y2;
	CComplex c1,c2,c3;

	cout<<"输入四个实数:"<<endl;
	cin>>x1>>y1>>x2>>y2;
	c1.setValue(x1,y1);
	c2.setValue(x2,y2);
	cout<<"复数c1: "<<c1<<endl;
	cout<<"复数c2: "<<c2<<endl;
	c3=c1+c2;
	cout<<"c1+c2: "<<c3<<endl;
	cout<<"c1+x2: "<<c1+x2<<endl;
	cout<<"++c2: "<<++c2<<endl;
	cout<<"c2++: "<<c2++<<endl;
	cout<<"c2: "<<c2<<endl;

	//system("pause");
	return 0;
} `
# E26 [第8章：静态成员]现需要处理银行活期存款业务，设账户类为，CAount，请根据如下需求实现该类，并在 main函数中测试。
	每个账户需要有一个浮点型的成员m_Money用于存储账上余额；
	每个账户需要描述存款的日期；
	银行的年利息采用浮点型静态数据成员m_InterestRate描述，从而避免为每个账户存储利息；
	为年利息成员提供静态成员SetInterestRate进行设置；
	为年利息成员提供静态成员GetInterestRate进行获取；
	提供存款成员函数SaveMoney；
	提供取款成员函数LendMoney；
	提供计算利息函数CalcInterest，计算存款中指定金额(通过参数传入)到当前日期的利息，方便取款和结算利息。如果金额大于账户本金，利息为0，表示无法计算。
	提供结算利息函数SaveInterest，该函数将计算出的利息结算到本金中。
	提供输出运算符重载函数，输出内容：存款日期，账户余额，当前利率。
示例：2014-1-1 10000 0.1 
	为简化计算，请考虑以下定义或限制：
(1).	本题目不考虑闰年，每个月都认为30天，一年认为360天。
(2).	存款仅考虑发生一次！
(3).	取款允许发生多次，但取款是否允许需要考虑“本金是否足够”的条件
	银行相关业务和利息的计算方法举例如下：
(1).	假设年利率m_InterestRate=0.036（表示 3.6%）。m_InterestRate是静态成员变量，按照静态成员变量的概念，对所有账户 CAount类的对象而言m_InterestRate只有  1个，这样才能实现一改全改的效果！
(2).	我于  2014-1-1到银行存了 100000元，m_Money=100000。
(3).	2014-3-10银行给我“结算利息”一次。2014-1-1到  2014-3-10之间一共间隔了70天，本金  m_Money=100000+100000*0.036/360*70=100700。“结算利息”以后，存款日期变为了 2014-3-10！
(4).	2014-3-30我到银行想取款  200000，由于本金 m_Money只有 100700，所以不允许取款！
(5).	2014-4-4我到银行想取款50000，由于本金有100700，所以允许取款。2014-3-10到2014-4-4之间一共间隔了 25天，本次取得的金额是50000+50000*0.036/360*25=50125，本金m_Money=100700-50000=50700（利息不从我的账户中扣除，这是由银行提供给我的回报），存款日期仍然维持为2014-3-10
// 为了便于测试，提供一个系统日期类，并定义全局对象表示当前系统日期
 `class CSystemTime
{
private:
    int m_year, m_month, m_day;
public:
    void setDate(int y,int m, int d)
    {
        m_year=y;
        m_month=m;
        m_day=d;
    }
    int getYear()const{return m_year;}
    int getMonth()const{return m_month;}
    int getDay()const{return m_day;}
};

CSystemTime  systemTime;   // 全局变量表示当前系统时间


int main()
{
    CAount aount;
    int year,month, day;
    double money,istate;
    cout<<"输入当前日期(年月日):"<<endl;
    cin>>year>>month>>day;
    systemTime.setDate(year,month,day);
    cout<<"输入存款金额:"<<endl;
    cin>>money;
    aount.SaveMoney(money);
    cout<<"当前账户信息:"<<endl;
    cout<<aount<<endl;

    cout<<"输入新的日期(年月日):"<<endl;
    cin>>year>>month>>day;
    systemTime.setDate(year,month,day);
    aount.SaveInterest();
    cout<<"当前账户信息:"<<endl;
    cout<<aount<<endl;

    cout<<"输入新的日期(年月日):"<<endl;
    cin>>year>>month>>day;
    systemTime.setDate(year,month,day);
    CAount::SetInterestRate(0.2);
    cout<<"输入取款金额:"<<endl;
    cin>>money;
    istate=aount.LendMoney(money);
    if (istate<0)
        cout<<"账户本金不足"<<endl;
    else
        cout<<"取款: "<<istate<<endl;

    cout<<"当前账户信息:"<<endl;
    cout<<aount<<endl;
	//system("pause");
	return 0;
} `

